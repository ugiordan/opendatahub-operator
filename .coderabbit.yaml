# yaml-language-server: $schema=https://coderabbit.ai/integrations/schema.v2.json

# CodeRabbit Configuration - Automated Security Scanning
# Generated by security-findings-manager plugin
# This enables PR-level security scanning with the same tools used in full scans

language: "en-US"
early_access: false

tone_instructions: "Focus on security vulnerabilities, code quality issues, and best practices. Provide CVE/CWE IDs, severity ratings, and detailed remediation for security findings."

reviews:
  profile: chill

  request_changes_workflow: false  # Non-blocking for development velocity

  high_level_summary: true
  review_status: true
  collapse_walkthrough: false
  poem: false

  commit_status: true
  fail_commit_status: false

  # Security scanning tools (matching full security scan)
  tools:
    # Pattern-based secret detection
    gitleaks:
      enabled: true

    # Custom security rules
    semgrep:
      enabled: true

    # Shell script security
    shellcheck:
      enabled: true

    # YAML validation
    yamllint:
      enabled: true

    # Markdown linting
    markdownlint:
      enabled: true

    # Dockerfile best practices
    hadolint:
      enabled: true

    # Kubernetes manifest security
    checkov:
      enabled: true

  # Path-specific security instructions
  path_instructions:
    # Kubernetes manifests
    - path: "**/*.yaml"
      instructions: |
        KUBERNETES SECURITY CHECKS:
        1. No privileged containers or hostPath mounts
        2. Resource limits defined (memory, CPU)
        3. No wildcard RBAC permissions
        4. SecurityContext configured appropriately
        5. No secrets in plain text

    # Docker files
    - path: "**/Dockerfile*"
      instructions: |
        DOCKERFILE SECURITY:
        1. Use specific base image tags (not :latest)
        2. Run as non-root user
        3. No hardcoded secrets
        4. Minimize layers and attack surface
        5. Verify package signatures

    # Shell scripts
    - path: "**/*.sh"
      instructions: |
        SHELL SCRIPT SECURITY:
        1. Quote all variables to prevent injection
        2. Use absolute paths for commands
        3. Validate all user inputs
        4. No eval or exec with untrusted input
        5. Proper error handling

    # Go operator code
    - path: "**/*.go"
      instructions: |
        GO OPERATOR SECURITY (Kubernetes Controllers):

        EXTERNAL API INTEGRATION:
        1. Use io.LimitReader for HTTP response bodies (prevent memory exhaustion)
           Example: io.ReadAll(io.LimitReader(resp.Body, 10*1024*1024))
        2. Validate all data from json.Unmarshal before storing in ConfigMaps/Secrets
           - Check length limits (prevent resource exhaustion)
           - Validate character patterns (no shell metacharacters: $, `, |, ;, &)
           - Enforce format constraints (regex validation)
        3. No InsecureSkipVerify in TLS configs (enables MITM attacks)
        4. Verify API response schemas match expected structure

        KUBERNETES RESOURCE MANIPULATION:
        5. Validate CR spec fields before using in ConfigMaps/Secrets
           - No direct CR.Spec.Field → ConfigMap.Data without validation
           - Check for injection patterns (shell commands, path traversal)
        6. Set OwnerReferences on all child resources (prevents orphaned resources)
           - Use controllerutil.SetControllerReference(parent, child, scheme)
        7. No wildcard RBAC permissions in ClusterRole/Role manifests

        COMMAND EXECUTION:
        8. Validate inputs before exec.Command (prevent command injection)
           - Use allowlist regex patterns for paths/arguments
           - Check for shell metacharacters (;|&$`<>(){}[])
           - Use filepath.Abs to prevent path traversal
           - Never use exec.Command("/bin/sh", "-c", userInput)

        SECRETS MANAGEMENT:
        9. Never log sensitive fields (Password, Token, APIKey, Secret.Data)
           - Redact secrets before logging: log.Info("key", redact(secret))
        10. Avoid weak cryptography (MD5, SHA1) for security operations

        DATA FLOW ANALYSIS:
        - Trace user-controlled data from CR spec → ConfigMap → Pod
        - Ensure validation at trust boundaries (webhook, reconciler)
        - Verify no injection vulnerabilities in data flow chain

    # Python code
    - path: "**/*.py"
      instructions: |
        PYTHON SECURITY:
        1. No eval() or exec() with untrusted input
        2. Use parameterized queries (no SQL injection)
        3. Validate file paths (no path traversal)
        4. No shell=True in subprocess
        5. Proper input sanitization

  # Exclude non-relevant paths
  path_filters:
    - "!.git/**"
    - "!vendor/**"
    - "!**/__pycache__/**"
    - "!**/*.pyc"

  auto_review:
    enabled: true
    drafts: false
    ignore_title_keywords:
      - "WIP"
      - "DO NOT MERGE"
    base_branches:
      - main
      - master
      - incubation

knowledge_base:
  learnings:
    scope: local
  issues:
    scope: local
